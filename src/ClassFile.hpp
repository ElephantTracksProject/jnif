/*
 * ClassFile.hpp
 *
 *  Created on: Jun 11, 2014
 *      Author: luigi
 */

#ifndef JNIF_CLASSFILE_HPP
#define JNIF_CLASSFILE_HPP

#include "ConstPool.hpp"
#include "Version.hpp"
#include "Attr.hpp"
#include "Inst.hpp"
#include "Arena.hpp"

namespace jnif {

    class Signature {
    public:

        Signature(const Attrs* attrs) : attrs(attrs) {
        }

        bool hasSignature() const {
            for (Attr* attr : *attrs) {
                if (attr->kind == ATTR_SIGNATURE) {
                    return true;
                }
            }

            return false;
        }

        const char* signature() const {
            for (Attr* attr : *attrs) {
                if (attr->kind == ATTR_SIGNATURE) {
                    return ((SignatureAttr*) attr)->signature();
                }
            }

            return NULL;
        }

    private:

        const Attrs* attrs;

    };

    /// Represent a member of a class. This the base class for Field and
    /// Method classes.
    /// @see Field
    /// @see Method
    class Member {

        Member(const Member&) = delete;
        Member(Member&&) = delete;
        Member& operator=(const Member&) = delete;
        Member& operator=(Member&&) = delete;

        friend class Field;
        friend class Method;

    public:

        const u2 accessFlags;
        const ConstPool::Index nameIndex;
        const ConstPool::Index descIndex;
        const ConstPool* const constPool;
        Attrs attrs;
        Signature sig;

        const char* getName() const;
        const char* getDesc() const;

    private:

        Member(
            u2 accessFlags,
            ConstPool::Index nameIndex,
            ConstPool::Index descIndex,
            const ConstPool* constPool
            ) :
            accessFlags(accessFlags),
            nameIndex(nameIndex),
            descIndex(descIndex),
            constPool(constPool),
            sig(&attrs)
        {
        }
    };

    class Field: public Member {

        Field(const Field&) = delete;
        Field(Field&&) = delete;
        Field& operator=(const Field&) = delete;
        Field& operator=(Field&&) = delete;

    public:

        /// Access flags used by fields.
        enum Flags {

            /// Declared public; may be accessed from outside its package.
            PUBLIC = 0x0001,

            /// Declared private; usable only within the defining class.
            PRIVATE = 0x0002,

            /// Declared protected; may be accessed within subclasses.
            PROTECTED = 0x0004,

            /// Declared static.
            STATIC = 0x0008,

            /// Declared final;never directly assigned to after object construction.
            FINAL = 0x0010,

            /// Declared volatile; cannot be cached.
            VOLATILE = 0x0040,

            /// Declared transient; not written/read by a persistent object manager.
            TRANSIENT = 0x0080,

            /// Declared synthetic; not present in the source code.
            SYNTHETIC = 0x1000,

            /// Declared as an element of an enum.
            ENUM = 0x4000
        };

        Field(
            u2 accessFlags,
            ConstPool::Index nameIndex,
            ConstPool::Index descIndex,
            const ConstPool* constPool) :
            Member(accessFlags, nameIndex, descIndex, constPool)
        {
        }

    };

    /// Represents a Java method.
    class Method: public Member {

        Method(const Method&) = delete;
        Method(Method&&) = delete;
        Method& operator=(const Method&) = delete;
        Method& operator=(Method&&) = delete;

    public:

        /// Access flags used by methods.
        enum Flags {

            /// Declared public; may be accessed from outside its package.
            PUBLIC = 0x0001,

            /// Declared private; accessible only within the defining class.
            PRIVATE = 0x0002,

            /// Declared protected; may be accessed within subclasses.
            PROTECTED = 0x0004,

            /// Declared static.
            STATIC = 0x0008,

            /// Declared final; must not be overridden (see 5.4.5).
            FINAL = 0x0010,

            /// Declared synchronized; invocation is wrapped by a monitor use.
            SYNCHRONIZED = 0x0020,

            /// A bridge method, generated by the compiler.
            BRIDGE = 0x0040,

            /// Declared with variable number of arguments.
            VARARGS = 0x0080,

            /// Declared native; implemented in a language other than Java.
            NATIVE = 0x0100,

            /// Declared abstract; no implementation is provided.
            ABSTRACT = 0x0400,

            /// Declared strictfp; floating-point mode is FP-strict.
            STRICT = 0x0800,

            /// Declared synthetic; not present in the source code.
            SYNTHETIC = 0x1000,

        };

        Method(
            u2 accessFlags,
            ConstPool::Index nameIndex,
            ConstPool::Index descIndex,
            const ConstPool* constPool) :
            Member(accessFlags, nameIndex, descIndex, constPool)
        {
        }

        ~Method();

        bool hasCode() const {
            for (Attr* attr : attrs) {
                if (attr->kind == ATTR_CODE) {
                    return true;
                }
            }

            return false;
        }

        CodeAttr* codeAttr() const {
            for (Attr* attr : attrs) {
                if (attr->kind == ATTR_CODE) {
                    return (CodeAttr*) attr;
                }
            }

            return NULL;
        }

        InstList& instList();

        bool isPublic() const {
            return accessFlags & PUBLIC;
        }

        bool isStatic() const {
            return accessFlags & STATIC;
        }

        bool isInit() const;

        bool isMain() const;

        /**
         * Shows this method in the specified ostream.
         */
        friend std::ostream& operator<<(std::ostream& os, const Method& m);

    };

    class IClassPath {
    public:

        virtual ~IClassPath() {
        }

        virtual String getCommonSuperClass(const String& className1,
                                           const String& className2) = 0;

    };

    /// Models a Java Class File following the specification of the JVM version 7.
    class ClassFile: public ConstPool {

        ClassFile(const ClassFile&) = delete;
        ClassFile(ClassFile&&) = delete;
        ClassFile& operator=(const ClassFile&) = delete;
        ClassFile& operator=(ClassFile&&) = delete;

    public:

        /// Access flags for the class itself.
        enum Flags {

            /// Declared public; may be accessed from outside its package.
            PUBLIC = 0x0001,

            /// Declared final; no subclasses allowed.
            FINAL = 0x0010,

            /// Treat superclass methods specially when invoked by the
            /// invokespecial instruction.
            SUPER = 0x0020,

            /// Is an interface, not a class.
            INTERFACE = 0x0200,

            /// Declared abstract; must not be instantiated.
            ABSTRACT = 0x0400,

            /// Declared synthetic; not present in the source code.
            SYNTHETIC = 0x1000,

            /// Declared as an annotation type.
            ANNOTATION = 0x2000,

            /// Declared as an enum type.
            ENUM = 0x4000
        };

        /// The magic number signature that must appear at the beginning of each
        /// class file, identifying the class file format;
        /// it has the value 0xCAFEBABE.
        static constexpr const u4 MAGIC = 0xcafebabe;

        /// Java's root class
        static constexpr const char* OBJECT = "java/lang/Object";

        /// Constructs a default class file given the class name, the super class
        /// name and the access flags.
        ClassFile(
            const char* className,
            const char* superClassName,
            u2 accessFlags = PUBLIC,
            u2 majorVersion = 51,
            u2 minorVersion = 0
            ) :
            version(majorVersion, minorVersion),
            accessFlags(accessFlags),
            thisClassIndex(addClass(className)),
            superClassIndex(addClass(superClassName)),
            sig(&attrs)
        {
        }

        /**
         * Constructs a class file from an in-memory representation of the java
         * class file.
         */
        ClassFile(const u1* classFileData, int classFileLen);

        ClassFile(const char* fileName);

        /**
         * Gets the class name of this class file.
         */
        const char* getThisClassName() const {
            return getClassName(thisClassIndex);
        }

        /**
         *
         */
        const char* getSuperClassName() const {
            return getClassName(superClassIndex);
        }

        bool isInterface() {
            return accessFlags & INTERFACE;
        }

        /**
         * Adds a new field to this class file.
         *
         * @param nameIndex the utf8 index in the constant pool that contains the
         * name of the field to add.
         * @param descIndex the utf8 index in the constant pool that contains the
         * descriptor of the field to add.
         * @param accessFlags the access flags of the field to add.
         * @returns the newly created field.
         */
        Field& addField(
            ConstPool::Index nameIndex,         ConstPool::Index descIndex, u2 accessFlags = Field::PUBLIC);

        /**
         * Adds a new field to this class file by passing directly the name
         * and descriptor.
         *
         * @param fieldName the name of the field to add.
         * @param fieldDesc the descriptor of the field to add.
         * @param accessFlags the access flags of the field to add.
         * @returns the newly created field.
         */
        Field& addField(const char* fieldName, const char* fieldDesc, u2 accessFlags = Field::PUBLIC) {
            ConstPool::Index nameIndex = addUtf8(fieldName);
            ConstPool::Index descIndex = addUtf8(fieldDesc);

            return addField(nameIndex, descIndex, accessFlags);
        }

        /**
         * Adds a new method to this class file.
         *
         * @param nameIndex the utf8 index in the constant pool that contains the
         * name of the method to add.
         * @param descIndex the utf8 index in the constant pool that contains the
         * descriptor of the method to add.
         * @param accessFlags the access flags of the field to add.
         * @returns the newly created method.
         */
        Method& addMethod(        ConstPool::Index nameIndex,         ConstPool::Index descIndex, u2 accessFlags = Method::PUBLIC);

        /**
         * Adds a new method to this class file by passing directly the name
         * and descriptor.
         *
         * @param methodName the name of the method to add.
         * @param methodDesc the descriptor of the method to add.
         * @param accessFlags the access flags of the method to add.
         * @returns the newly created method.
         */
        Method& addMethod(
            const char* methodName,
            const char* methodDesc, u2 accessFlags = Method::PUBLIC
            ) {
            ConstPool::Index nameIndex = addUtf8(methodName);
            ConstPool::Index descIndex = addUtf8(methodDesc);

            return addMethod(nameIndex, descIndex, accessFlags);
        }

        /**
         * Computes the size in bytes of this class file of the in-memory
         * representation.
         */
        u4 computeSize();

        /**
         *
         */
        void computeFrames(IClassPath* classPath);

        /**
         * Writes this class file in the specified buffer according to the
         * specification.
         */
        void write(u1* classFileData, int classFileLen);

        /**
         * Export this class file to dot format.
         *
         * @see www.graphviz.org
         */
        void dot(std::ostream& os) const;

        // Must be the first member, as it is needed for the destructors of the other members.
        Arena _arena;

        Version version;
        u2 accessFlags;
        ConstPool::Index thisClassIndex;
        ConstPool::Index superClassIndex;
        std::list<ConstPool::Index> interfaces;
        std::list<Field> fields;
        std::list<Method> methods;
        Attrs attrs;
        Signature sig;
    };

    std::ostream& operator<<(std::ostream& os, const ClassFile& classFile);

}

#endif
