/*
 * base.hpp
 *
 *  Created on: Jun 11, 2014
 *      Author: luigi
 */
#ifndef JNIF_BASE_HPP
#define JNIF_BASE_HPP

#include <string>
#include <ostream>

namespace jnif {
/**
 * Represents a byte inside the Java Class File.
 * The sizeof(u1) must be equal to 1.
 */
typedef unsigned char u1;

/**
 * Represents two bytes inside the Java Class File.
 * The sizeof(u2) must be equal to 2.
 */
typedef unsigned short u2;

/**
 * Represents four bytes inside the Java Class File.
 * The sizeof(u4) must be equal to 4.
 */
typedef unsigned int u4;

/**
 * We use STL string.
 */
typedef std::string String;

/**
 * Represents the base exception that jnif can throw.
 */
class JnifException {
public:

	/**
	 * Creates an exception given the message and the stack trace.
	 *
	 * @param message contains information about exceptional situation.
	 * @param stackTrace the stack trace where this exception happened.
	 */
	JnifException(const String& message, const String& stackTrace = "") :
			_message(message), _stackTrace(stackTrace) {
	}

//	JnifException() {
//	}
//
//	JnifException(JnifException&& ex) :
//			_message(std::move(ex._message)) {
//	}

	/**
	 * Returns information about the exceptional situation.
	 */
	const String& message() const {
		return _message;
	}

	const String& stackTrace() const {
		return _stackTrace;
	}

	/**
	 * the stack trace where this exception happened.
	 */

//	template<typename T>
//	JnifException& operator<<(const T& arg) {
//		_message << arg;
//		return *this;
//	}
	/**
	 * Shows this.
	 */
	friend std::ostream& operator<<(std::ostream& os, const JnifException& ex);

private:

	String _message;

	String _stackTrace;

	//std::stringstream _message;

};

/**
 *
 */
class ParserException: public JnifException {
public:
};

class WriterException: public JnifException {
public:

	WriterException(const String& message, const String& stackTrace) :
			JnifException(message, stackTrace) {
	}
};

class InvalidMethodLengthException: public WriterException {
public:
	InvalidMethodLengthException(const String& message,
			const String& stackTrace) :
			WriterException(message, stackTrace) {
	}
};

/**
 * Access flags for the class itself.
 */
enum ClassFlags {

	/**
	 * Declared public; may be accessed from outside its package.
	 */
	CLASS_PUBLIC = 0x0001,

	/**
	 * Declared final; no subclasses allowed.
	 */
	CLASS_FINAL = 0x0010,

	/**
	 * Treat superclass methods specially when invoked by the
	 * invokespecial instruction.
	 */
	CLASS_SUPER = 0x0020,

	/**
	 * Is an interface, not a class.
	 */
	CLASS_INTERFACE = 0x0200,

	/**
	 * Declared abstract; must not be instantiated.
	 */
	CLASS_ABSTRACT = 0x0400,

	/**
	 * Declared synthetic; not present in the source code.
	 */
	CLASS_SYNTHETIC = 0x1000,

	/**
	 * Declared as an annotation type.
	 */
	CLASS_ANNOTATION = 0x2000,

	/**
	 * Declared as an enum type.
	 */
	CLASS_ENUM = 0x4000
};

/**
 * Access flags used by methods.
 */
enum MethodFlags {

	/**
	 * Declared public; may be accessed from outside its package.
	 */
	METHOD_PUBLIC = 0x0001,

	/**
	 * Declared private; accessible only within the defining class.
	 */
	METHOD_PRIVATE = 0x0002,

	/**
	 * Declared protected; may be accessed within subclasses.
	 */
	METHOD_PROTECTED = 0x0004,

	/**
	 * Declared static.
	 */
	METHOD_STATIC = 0x0008,

	/**
	 * Declared final; must not be overridden (see 5.4.5).
	 */
	METHOD_FINAL = 0x0010,

	/**
	 * Declared synchronized; invocation is wrapped by a monitor use.
	 */
	METHOD_SYNCHRONIZED = 0x0020,

	/**
	 * A bridge method, generated by the compiler.
	 */
	METHOD_BRIDGE = 0x0040,

	/**
	 * Declared with variable number of arguments.
	 */
	METHOD_VARARGS = 0x0080,

	/**
	 * Declared native; implemented in a language other than Java.
	 */
	METHOD_NATIVE = 0x0100,

	/**
	 * Declared abstract; no implementation is provided.
	 */
	METHOD_ABSTRACT = 0x0400,

	/**
	 * Declared strictfp; floating-point mode is FP-strict.
	 */
	METHOD_STRICT = 0x0800,

	/**
	 * Declared synthetic; not present in the source code.
	 */
	METHOD_SYNTHETIC = 0x1000,
};

/**
 * Access flags used by fields.
 */
enum FieldFlags {

	/**
	 * Declared public; may be accessed from outside its package.
	 */
	FIELD_PUBLIC = 0x0001,

	/**
	 * Declared private; usable only within the defining class.
	 */
	FIELD_PRIVATE = 0x0002,

	/**
	 * Declared protected; may be accessed within subclasses.
	 */
	FIELD_PROTECTED = 0x0004,

	/**
	 * Declared static.
	 */
	FIELD_STATIC = 0x0008,
	/**
	 * Declared final;
	 * never directly assigned to after object construction (JLS $17.5).
	 */
	FIELD_FINAL = 0x0010,

	/**
	 * Declared volatile; cannot be cached.
	 */
	FIELD_VOLATILE = 0x0040,

	/**
	 * Declared transient; not written or read by a persistent object manager.
	 */
	FIELD_TRANSIENT = 0x0080,

	/**
	 * Declared synthetic; not present in the source code.
	 */
	FIELD_SYNTHETIC = 0x1000,

	/**
	 * Declared as an element of an enum.
	 */
	FIELD_ENUM = 0x4000
};

/**
 *
 */
enum NewArrayType {
	NEWARRAYTYPE_BOOLEAN = 4,
	NEWARRAYTYPE_CHAR = 5,
	NEWARRAYTYPE_FLOAT = 6,
	NEWARRAYTYPE_DOUBLE = 7,
	NEWARRAYTYPE_BYTE = 8,
	NEWARRAYTYPE_SHORT = 9,
	NEWARRAYTYPE_INT = 10,
	NEWARRAYTYPE_LONG = 11
};

/**
 *
 */
enum AttrKind {
	ATTR_UNKNOWN,
	ATTR_SOURCEFILE,
	ATTR_CODE,
	ATTR_EXCEPTIONS,
	ATTR_LVT,
	ATTR_LVTT,
	ATTR_LNT,
	ATTR_SMT
};

}

#endif
