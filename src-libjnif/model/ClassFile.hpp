/*
 * ClassFile.hpp
 *
 *  Created on: Jun 11, 2014
 *      Author: luigi
 */

#ifndef JNIF_MODEL_CLASSFILE_HPP
#define JNIF_MODEL_CLASSFILE_HPP

#include "ConstPool.hpp"
#include "Version.hpp"
#include "attrs/Attr.hpp"
#include "Inst.hpp"
#include "Arena.hpp"
#include "Version.hpp"

#include "attrs/SignatureAttr.hpp"

namespace jnif::model {

    class Signature {
    public:

        Signature(const Attrs* attrs) : attrs(attrs) {
        }

        bool hasSignature() const {
            for (Attr* attr : *attrs) {
                if (attr->kind == ATTR_SIGNATURE) {
                    return true;
                }
            }

            return false;
        }

        const char* signature() const {
            for (Attr* attr : *attrs) {
                if (attr->kind == ATTR_SIGNATURE) {
                    return ((SignatureAttr*) attr)->signature();
                }
            }

            return NULL;
        }

    private:

        const Attrs* attrs;

    };

/// Represent a member of a class. This the base class for Field and
/// Method classes.
/// @see Field
/// @see Method
    class Member {

        Member(const Member&) = delete;

        Member(Member&&) = delete;

        Member& operator=(const Member&) = delete;

        Member& operator=(Member&&) = delete;

        friend class Field;

        friend class Method;

    public:

        const u2 accessFlags;
        const ConstPool::Index nameIndex;
        const ConstPool::Index descIndex;
        const ConstPool& constPool;
        Attrs attrs;
        Signature sig;

        const char* getName() const;

        const char* getDesc() const;

    private:

        Member(u2 accessFlags, ConstPool::Index nameIndex, ConstPool::Index descIndex, const ConstPool& constPool);

    };

    class Field : public Member {

        Field(const Field&) = delete;

        Field(Field&&) = delete;

        Field& operator=(const Field&) = delete;

        Field& operator=(Field&&) = delete;

    public:

        /// Access flags used by fields.
        enum Flags {

            /// Declared public; may be accessed from outside its package.
                    PUBLIC = 0x0001,

            /// Declared private; usable only within the defining class.
                    PRIVATE = 0x0002,

            /// Declared protected; may be accessed within subclasses.
                    PROTECTED = 0x0004,

            /// Declared static.
                    STATIC = 0x0008,

            /// Declared final;never directly assigned to after object construction.
                    FINAL = 0x0010,

            /// Declared volatile; cannot be cached.
                    VOLATILE = 0x0040,

            /// Declared transient; not written/read by a persistent object manager.
                    TRANSIENT = 0x0080,

            /// Declared synthetic; not present in the source code.
                    SYNTHETIC = 0x1000,

            /// Declared as an element of an enum.
                    ENUM = 0x4000
        };

        Field(
                jnif::u2 accessFlags,
                jnif::model::ConstPool::Index nameIndex,
                jnif::model::ConstPool::Index descIndex,
                const jnif::model::ConstPool& constPool) :
                Member(accessFlags, nameIndex, descIndex, constPool) {
        }

    };

/// Represents a Java method.
    class Method : public Member {

        Method(const Method&) = delete;

        Method(Method&&) = delete;

        Method& operator=(const Method&) = delete;

        Method& operator=(Method&&) = delete;

    public:

        /// Access flags used by methods.
        enum Flags {

            /// Declared public; may be accessed from outside its package.
                    PUBLIC = 0x0001,

            /// Declared private; accessible only within the defining class.
                    PRIVATE = 0x0002,

            /// Declared protected; may be accessed within subclasses.
                    PROTECTED = 0x0004,

            /// Declared static.
                    STATIC = 0x0008,

            /// Declared final; must not be overridden (see 5.4.5).
                    FINAL = 0x0010,

            /// Declared synchronized; invocation is wrapped by a monitor use.
                    SYNCHRONIZED = 0x0020,

            /// A bridge method, generated by the compiler.
                    BRIDGE = 0x0040,

            /// Declared with variable number of arguments.
                    VARARGS = 0x0080,

            /// Declared native; implemented in a language other than Java.
                    NATIVE = 0x0100,

            /// Declared abstract; no implementation is provided.
                    ABSTRACT = 0x0400,

            /// Declared strictfp; floating-point mode is FP-strict.
                    STRICT = 0x0800,

            /// Declared synthetic; not present in the source code.
                    SYNTHETIC = 0x1000,

        };

        Method(
                jnif::u2 accessFlags,
                jnif::model::ConstPool::Index nameIndex,
                jnif::model::ConstPool::Index descIndex,
                const jnif::model::ConstPool& constPool) :
                Member(accessFlags, nameIndex, descIndex, constPool) {
        }

        bool hasCode() const {
            for (Attr* attr : attrs) {
                if (attr->kind == jnif::ATTR_CODE) {
                    return true;
                }
            }

            return false;
        }

        CodeAttr* codeAttr() const {
            for (Attr* attr : attrs) {
                if (attr->kind == jnif::ATTR_CODE) {
                    return (CodeAttr*) attr;
                }
            }

            return NULL;
        }

        InstList& instList();

        bool isPublic() const {
            return accessFlags & PUBLIC;
        }

        bool isStatic() const {
            return accessFlags & STATIC;
        }

        bool isInit() const;

        bool isMain() const;

        /**
         * Shows this method in the specified ostream.
         */
        friend std::__1::ostream& operator<<(std::__1::ostream& os, const Method& m);

    };


    /// Models a Java Class File following the specification of the JVM version 7.
    class ClassFile : public ConstPool {

        ClassFile(const ClassFile&) = delete;

        ClassFile(ClassFile&&) = delete;

        ClassFile& operator=(const ClassFile&) = delete;

        ClassFile& operator=(ClassFile&&) = delete;

    public:

        /// Access flags for the class itself.
        enum Flags {

            /// Declared public; may be accessed from outside its package.
                    PUBLIC = 0x0001,

            /// Declared final; no subclasses allowed.
                    FINAL = 0x0010,

            /// Treat superclass methods specially when invoked by the
            /// invokespecial instruction.
                    SUPER = 0x0020,

            /// Is an interface, not a class.
                    INTERFACE = 0x0200,

            /// Declared abstract; must not be instantiated.
                    ABSTRACT = 0x0400,

            /// Declared synthetic; not present in the source code.
                    SYNTHETIC = 0x1000,

            /// Declared as an annotation type.
                    ANNOTATION = 0x2000,

            /// Declared as an enum type.
                    ENUM = 0x4000
        };

        /// The magic number signature that must appear at the beginning of each
        /// class file, identifying the class file format;
        /// it has the value 0xCAFEBABE.
        static constexpr const u4 MAGIC = 0xcafebabe;

        /// Java's root class
        static constexpr const char* OBJECT = "java/lang/Object";

        /**
         * The constructed ClassFile has no class name neither super class name.
         */
        ClassFile();

        /**
         * Constructs a ClassFile with a given class name.
         * @param className The class name of this ClassFile.
         */
        explicit ClassFile(const char* className);

        /**
         * Constructs a default class file given the class name, the super class
         * name and the access flags.
         *
         *
         */
        ClassFile(const char* className, const char* superClassName, u2 accessFlags = PUBLIC,
                  const Version& version = Version());

        /**
         * Gets the class name of this class file.
         *
         * @return The class name of this class file.
         */
        const char* getThisClassName() const {
            return getClassName(thisClassIndex);
        }

        /**
         *
         */
        const char* getSuperClassName() const {
            return getClassName(superClassIndex);
        }

        /**
         * Determines whether this class file is an interface.
         *
         * @return true when this class is an interface.
         * Otherwise false.
         */
        bool isInterface() {
            return accessFlags & INTERFACE;
        }

        /**
         * Adds a new field to this class file.
         *
         * @param nameIndex the utf8 index in the constant pool that contains the
         * name of the field to add.
         * @param descIndex the utf8 index in the constant pool that contains the
         * descriptor of the field to add.
         * @param accessFlags the access flags of the field to add.
         * @returns the newly created field.
         */
        Field& addField(ConstPool::Index nameIndex, ConstPool::Index descIndex, u2 accessFlags = Field::PUBLIC);

        /**
         * Adds a new field to this class file by passing directly the name
         * and descriptor.
         *
         * @param fieldName the name of the field to add.
         * @param fieldDesc the descriptor of the field to add.
         * @param accessFlags the access flags of the field to add.
         * @returns the newly created field.
         */
        Field& addField(const char* fieldName, const char* fieldDesc, u2 accessFlags = Field::PUBLIC) {
            ConstPool::Index nameIndex = addUtf8(fieldName);
            ConstPool::Index descIndex = addUtf8(fieldDesc);

            return addField(nameIndex, descIndex, accessFlags);
        }

        /**
         * Adds a new method to this class file.
         *
         * @param nameIndex the utf8 index in the constant pool that contains the
         * name of the method to add.
         * @param descIndex the utf8 index in the constant pool that contains the
         * descriptor of the method to add.
         * @param accessFlags the access flags of the field to add.
         * @returns the newly created method.
         */
        Method& addMethod(ConstPool::Index nameIndex, ConstPool::Index descIndex, u2 accessFlags = Method::PUBLIC);

        /**
         * Adds a new method to this class file by passing directly the name
         * and descriptor.
         *
         * @param methodName the name of the method to add.
         * @param methodDesc the descriptor of the method to add.
         * @param accessFlags the access flags of the method to add.
         * @returns the newly created method.
         */
        Method& addMethod(
                const char* methodName,
                const char* methodDesc, u2 accessFlags = Method::PUBLIC
        ) {
            ConstPool::Index nameIndex = addUtf8(methodName);
            ConstPool::Index descIndex = addUtf8(methodDesc);

            return addMethod(nameIndex, descIndex, accessFlags);
        }

        std::list<Method>::iterator getMethod(const char* methodName);

        /**
         * Computes the size in bytes of this class file of the in-memory
         * representation.
         */
        u4 computeSize();

        /**
         *
         */
        void computeFrames(IClassPath* classPath);

        /**
         * Writes this class file in the specified buffer according to the
         * specification.
         */
        void write(u1* classFileData, int classFileLen);

        /**
         * Export this class file to dot format.
         *
         * @see www.graphviz.org
         */
        void dot(std::ostream& os) const;

        // Must be the first member, as it is needed for the destructors of the other members.
        Arena _arena;

        Version version;
        u2 accessFlags = PUBLIC;
        ConstPool::Index thisClassIndex = ConstPool::NULLINDEX;
        ConstPool::Index superClassIndex = ConstPool::NULLINDEX;
        std::list<ConstPool::Index> interfaces;
        std::list<Field> fields;
        std::list<Method> methods;
        Attrs attrs;
        Signature sig;
    };

    std::ostream& operator<<(std::ostream& os, const ClassFile& classFile);

}

#endif
